# This function generates candidate cut points based on given outer boundary

# Input: max, min: right and left boundary
#        eps: granularity (roughtly, e.g., 0.05 will be treated as 0.01, see below how I got the digits for rounding)
#        option: different generating scheme
generate_candidate_cuts = function(max, min, eps, option = 1, x){
  if(max == min){
    return(list(cuts = c(max - eps, max + eps), x = x))
  }
  
  # check the input: 
  # if(max - min < 2 * eps){
  #   stop("error: invalid max and min in generate_candidate_cuts.R")
  # }
  
  if(max - min < 0.8 * eps){
    stop("error: invalid max and min in generate_candidate_cuts.R")
  }
  
  
  # get the digits for rounding
  if(eps >= 1){
    dig = -abs(floor(log10(eps)))
  } else{
    if(eps == 0){
      stop("eps cannot be 0!")
    } else{
      dig = abs(floor(log10(eps)))  
    }
  }
  
  
  if(option == 1){
    round_min = round(min, digits = dig)
    round_max = round(max, digits = dig)
    
    if(round_min > min){
      min = round_min - eps
    } else{
      min = round_min
    }
    
    if(round_max < max){
      max = round_max + eps
    } else if(round_max == max){
      x[x==max] = x[x==max] - eps/(10^4)
    } 
    else{
      max = round_max
    }
    
    cuts = seq(min, max, by = eps)
    # make sure that the last cut point is the right outer boundary
    # and make sure that the rightmost interval is close on both sides. 
    # if(correct_for_last){
    #   cuts[length(cuts)] = max + eps 
    # }
  }
  
  # round the cuts to correct for floating points error, e.g., 0.7+0.1==0.8 return FALSE
  # That is, when we use seq(), the sequence is generated by "incrementation", which accumulates floating point error. 
  cuts = round(cuts, digits = dig)
  if(cuts[1] > min){ # correct for the rounding, in case min < cuts[1]
    cuts[1] = cuts[1] - eps
  }
  if(cuts[length(cuts)] < max ){ # correct for the rounding
    cuts[length(cuts)] = cuts[length(cuts)] + eps
  }
  
  # if(!correct_for_last){ # correct for the rounding, in case max > cuts[length(cuts)]
  #   if(cuts[length(cuts)] < max ){
  #     cuts[length(cuts)] = cuts[length(cuts)] + eps
  #   }
  # }
  return(list(cuts = cuts, x=x))
}